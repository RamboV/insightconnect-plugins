import komand
from .schema import MapInsightvmVulnerabilityToHostDatabaseInput, MapInsightvmVulnerabilityToHostDatabaseOutput, Input, Output, Component
# Custom imports below
from komand.exceptions import PluginException
from komand_cisco_firepower.util.utils import generate_payload

import komand_cisco_firepower.util.read_csv as csv_reader
import base64


class MapInsightvmVulnerabilityToHostDatabase(komand.Action):

    def __init__(self):
        super(self.__class__, self).__init__(
                name='map_insightvm_vulnerability_to_host_database',
                description=Component.DESCRIPTION,
                input=MapInsightvmVulnerabilityToHostDatabaseInput(),
                output=MapInsightvmVulnerabilityToHostDatabaseOutput())

    def run(self, params={}):
        csv_encoded = params.get(Input.CSV)
        timeout = params.get(Input.TIMEOUT)

        try:
            csv_string = base64.b64decode(csv_encoded).decode("utf-8")
        except Exception as e:
            self.logger.error(str(e))
            raise PluginException(PluginException.Preset.BASE64_DECODE)

        headers, vuln_list = csv_reader.read_csv(csv_string)

        # TODO: YOU ARE HERE
        # CSV HEADERS
        """
        [
        'asset_id', 
        'ip_address', 
        'port', 
        'protocol_id', 
        'title', 
        'vulnerability_id', 
        'nexpose_id', 
        'references', 
        'severity_score', 
        'pci_severity_score', 
        'cvss_score', 
        'cvss_vector', 
        'vendor', 
        'name', 
        'version'
        ]
        """

        # NEED TO CONSTRUCT THIS:
        """
        AddHost,1.2.3.5
        AddScanResult,1.2.3.5,"Qualys",82003,,,"ICMP Timestamp Request","ICMP (Internet Control and Error Message Protocol) is a protocol encapsulated in IP packets. Its principal purpose is to provide a protocol layer able to inform gateways of the inter-connectivity and accessibility of other gateways or hosts. ping is a well-known program for determining if a host is up or down. It uses ICMP echo packets. ICMP timestamp packets are used to synchronize clocks between hosts.","cve_ids: CVE-1999-0524","bugtraq_ids:"
        """

        # NOTE: Adding a host that already exists is ignored
        """
        AddHost, mac or ip
        """

        """
        AddScanResult, ipaddr, scanner_id, vuln_id, port, protocol, name, description, cve_ids, bugtraq_ids
        """

        #SCAN RESULTS LOOK LIKE THIS:
        """
        {
            host: {
                ip_address:
                operating_system: {}
                name:
                vendor:
                version:
            }
            scan_result_details: {
                source_id: 3, # application
                port: 
                protocol_id:
                scanner_id:
                vulnerability_id:
                description:
                vulnerability_title:
                cve_ids: <unkown format, string or list>
                bugtraq_ids: <unkown format, string or list>                
            }            
        }
        """

        vuln_objects = self.convert_csv_to_scan_results(vuln_list)
        operation = "ScanUpdate"

        total = len(vuln_objects)
        increment = 1
        start_index = 0
        end_index = start_index + increment

        processed = 0
        errors = 0

        self.logger.info(f"Total records to process: {total}")

        while start_index < total and start_index < 5: # TODO: REMOVE < 50

            if start_index > 0:
                self.connection.make_connection()

            self.logger.info(f"Processing {start_index} through {end_index}")
            current_vuln_objects = vuln_objects[start_index: end_index]

            payload = generate_payload(current_vuln_objects, operation, self.connection.max_data_size)
            print("*************************")
            print("Payload")
            print(payload)
            print("*************************")
            self.logger.info('Sending payload to Firepower.')
            cur_processed, cur_errors = self.connection.send(payload, timeout)
            self.connection.close()

            processed += cur_processed
            errors += cur_errors

            start_index = end_index + 1
            end_index = start_index + increment


        return {
            Output.ERRORS: errors,
            Output.COMMANDS_PROCESSED: processed
        }

    def convert_csv_to_scan_results(self, vuln_list):
        scan_results = []
        """
        [        
        'asset_id', 
        'ip_address', 
        'port', 
        'protocol_id', 
        'title', 
        'vulnerability_id', 
        'nexpose_id', 
        'references', 
        'severity_score', 
        'pci_severity_score', 
        'cvss_score', 
        'cvss_vector', 
        'vendor', 
        'name', 
        'version'        
        ]
        """

        for vuln in vuln_list:
            scan_result = \
            {
                "host": {
                    "ip_address": vuln.get("ip_address", ""),
                    "operating_system": {
                        "name": vuln.get("name", ""),
                        "vendor": vuln.get("vendor", ""),
                        "version": vuln.get("version", ""),
                    },
                },
                "scan_result_details": {
                    "source_id": "InsightVM", # application
                    "port": vuln.get("port", ""),
                    "protocol_id": vuln.get("protocol_id", ""),
                    "scanner_id": "InsightVM",
                    "vulnerability_id": vuln.get("vulnerability_id", ""),
                    "description": vuln.get("description", ""),
                    "vulnerability_title": vuln.get("title", ""),
                    "cve_ids": "", # Space-separated list of CVE vulnerability IDs
                    "bugtraq_ids": "", # Space-separated list of BugTraq vulnerability IDs
                }
            }

            scan_results.append(scan_result)
        return scan_results

